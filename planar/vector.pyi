from _typeshed import Incomplete
from planar.util import assert_unorderable as assert_unorderable, cached_property as cached_property, cos_sin_deg as cos_sin_deg
from typing import Tuple, Union

class Vec2(Tuple[float, float]):
    def __new__(self, x: float, y: float) -> Vec2: ...
    @classmethod
    def polar(cls, angle: float, length: float = ...) -> Vec2: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def length(self) -> float: ...
    @property
    def length2(self) -> float: ...
    @property
    def is_null(self): ...
    def __bool__(self): ...
    def almost_equals(self, other): ...
    def normalized(self) -> Vec2: ...
    def perpendicular(self) -> Vec2: ...
    def dot(self, other: Vec2) -> float: ...
    def cross(self, other): ...
    @property
    def angle(self) -> float: ...
    def angle_to(self, other: Vec2) -> float: ...
    def distance_to(self, other: Vec2) -> float: ...
    def rotated(self, angle: float) -> Vec2: ...
    def scaled_to(self, length: float) -> Vec2: ...
    def project(self, other: Vec2) -> Vec2: ...
    def reflect(self, other: Vec2) -> Vec2: ...
    def clamped(self, min_length: Incomplete | None = ..., max_length: Incomplete | None = ...) -> Vec2: ...
    def lerp(self, other, bias): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __gt__(self, other): ...
    def __ge__(self, other): ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __add__(self, other: Vec2) -> Vec2: ...
    __iadd__: Incomplete
    def __sub__(self, other: Vec2) -> Vec2: ...
    __isub__: Incomplete
    def __mul__(self, other: Union[Vec2, float]) -> Vec2: ...
    def __rmul__(self, other: Union[Vec2, float]) -> Vec2: ...
    def __truediv__(self, other): ...
    __itruediv__: Incomplete
    def __rtruediv__(self, other): ...
    def __floordiv__(self, other): ...
    __ifloordiv__: Incomplete
    def __rfloordiv__(self, other): ...
    def __pos__(self) -> Vec2: ...
    def __neg__(self) -> Vec2: ...
    def __abs__(self) -> float: ...
    __hash__: Incomplete

null: Incomplete

class Seq2:
    def __init__(self, vectors) -> None: ...
    @classmethod
    def from_points(cls, points): ...
    def __len__(self): ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, value) -> None: ...
    def __iter__(self): ...
    def __imul__(self, other): ...
    def almost_equals(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __copy__(self, memo: Incomplete | None = ...): ...
    __deepcopy__: Incomplete
    def __bool__(self): ...
    def __hash__(self): ...

class Vec2Array(Seq2):
    def __init__(self, vectors=...) -> None: ...
    def __getitem__(self, index): ...
    def __setitem__(self, index, value) -> None: ...
    def append(self, vector) -> None: ...
    def extend(self, iterable) -> None: ...
    def insert(self, index, vector) -> None: ...
    def __delitem__(self, index) -> None: ...
    def longest(self): ...
    def shortest(self): ...
    def normalized(self): ...
    def normalize(self) -> None: ...
    def clamped(self, min_length: Incomplete | None = ..., max_length: Incomplete | None = ...): ...
    def clamp(self, min_length: Incomplete | None = ..., max_length: Incomplete | None = ...) -> None: ...
    def __add__(self, other): ...
    __radd__: Incomplete
    def __iadd__(self, other): ...
    def __sub__(self, other): ...
    def __rsub__(self, other): ...
    def __isub__(self, other): ...
    def __mul__(self, other): ...
    __rmul__: Incomplete
    def __imul__(self, other): ...
    def __truediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __itruediv__(self, other): ...
    def __floordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __ifloordiv__(self, other): ...
    def __pos__(self): ...
    def __neg__(self): ...
